## 거래번호 채번

증권사 거래내역의 거래번호는 테이블 채번을 사용한다. 거래내역이 계좌기준으로 생성됨으로 계좌기본테이블을 FOR UPDATE하는 형태로 채번을 하는 경우도 있지만 나는 채번 테이블을 별도로 사용해 거래번호를 채번한다.

## 1. 테이블 구조

- 개별계좌번호 (PK)
- 최종거래일자
- 최종거래번호

## 2. 테이블 레코드 생성 규칙

채번테이블은 개별계좌 생성 시마다, 예수금테이블과 채번테이블에 개별계좌기준으로 레코드가 추가된다. 결국, 개별계좌수 = 예수금테이블 레코드수 = 채번테이블 레코드 수 가 된다.

## 3. 테이블 갱신 규칙

채번 프로그램을 별도로 두어 INPUT을 일자와 계좌번호를 받는다. 입력일자가 당 거래일과 같으면, 채번을 한다. 만약 당 거래일과 같지 않으면 오류를 낸다. (과거 또는 미래 일자 채번은 할 수 없다.) 채번은 채번테이블의 최종거래일자와 최종거래번호를 갱신한다.



## 4. 채번 테이블을 사용하는 이유는

**첫번째, 연번을 사용해야 하기때문이다.** 거래번호는 연번이어야 한다. - 증권회사의 업무적인 규칙이다. 만약 채번이 중간중간 비어있게 되면, 고객이 거래내역을 보고 숨겨진 거래에 대해 항의 해 올 수 있다.

**두번째, 계좌별로 논리적인 LOCK을 잡기 위해서 이다.** 과거 계좌기본테이블에 채번과 최종 거래일자, 최종 거래번호 컬럼을 둬 계좌기본테이블에 LOCK을 잡았지만 테이블의 목적과 맞지 않는다(계좌기본는 계좌의 정보를 담는 것이지, 거래와 연관짓는 정보를 관리하면 테이블의 목적에 맞지않는 업무가 추가된다.) 다른 방식으로 채번을 해야한다. 그렇다면 채번테이블 별도로 두고, 모든 거래 발생전(입/출금고, 매수매도) 채번을 하면 일자, 계좌별로 한 계좌에 여러 거래가 동시에 들어올 경우, 채번테이블의 선점으로 거래순서가 정해진다.

채번테이블을 사용하면 다음과 같은 장점을 얻을 수 있다. 금융 거래는 24 X 365 진행되는데, 새벽 계좌별결제(수도결제 포함)시 고객에의한 거래 발생시 해당 계좌는 채번프로그램에서 결제순서를 앞당기도록 호출하고, 고객거래가 SEAMLESS하게 진행할 수 있게 해준다.

가끔씩 채번테이블이 거래의 락을 잡는데, 예수금테이블 또는 잔고 테이블의 LOCK을 잡지 않는 이유에 대해 물어오는 경우가 있다. 거래를 발생시킬때, 항상 채번이 먼저 해야함으로 예수금테이블 또는 잔고 테이블LOCK을 잡을 필요가 없다. 다른 이유로는, 만약 채번을 예수금또는 잔고 갱신이후에 된다고 하면 과연 다른 개발자 입장에서 과연 예수금과 잔고 테이블 중 어떤 테이블의 LOCK을 먼저 잡을지 고민이 된다. 따라서, 계좌의 거래의 논리적 LOCK을 잡을 수 있는 채번프로그램을 먼저 호출 하는게 맞다.

## 5. 어떤 채번들이 있는가?

#### 1)  MAX+1 을 사용해 채번을 한다.

이력성 테이블 중 사용빈도가 낮고, 채번의 중요성이 낮을 경우 간단히 사용할 수 있다. 이 경우 NVL 함수를 사용할 수 없음으로, 초기값이 NULL 인 경우, 채번이 안된다. DUP이 발생할 확률이 많다.

#### 2) 오라클 시퀀스

채번이 연번일 필요가 없을 경우 좋다. 연번이 필요할 경우 사용할 수 없고, 초기화 주기를 설정해야한다.

#### 3) 테이블 채번

연번이면서, 공통으로 사용되는 이력성 테이블에 사용된다. 서로 다른 세션에서 채번 순서가 불규칙 할 경우 DEAD LOCK이 발생할 수 있다